package com.ita.if103java.ims.dao.impl;

import com.ita.if103java.ims.dao.WarehouseDao;
import com.ita.if103java.ims.entity.Warehouse;
import com.ita.if103java.ims.exception.CRUDException;
import com.ita.if103java.ims.exception.EntityNotFoundException;
import com.ita.if103java.ims.exception.WarehouseNotFoundException;
import com.ita.if103java.ims.mapper.jdbc.WarehouseRowMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import java.util.Optional;

@Repository
public class WarehouseDaoImpl implements WarehouseDao {
    private static final Logger LOGGER = LoggerFactory.getLogger(WarehouseDaoImpl.class);
    private JdbcTemplate jdbcTemplate;
    private WarehouseRowMapper warehouseRowMapper;


    @Autowired
    public WarehouseDaoImpl(DataSource dataSource, WarehouseRowMapper warehouseRowMapper) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.warehouseRowMapper = warehouseRowMapper;
    }

    private PreparedStatement createWarehouseStatement(Warehouse warehouse, Connection connection) throws SQLException {
        int i = 0;
        PreparedStatement statement = connection.prepareStatement(Queries.SQL_CREATE_WAREHOUSE,
            PreparedStatement.RETURN_GENERATED_KEYS);
        statement.setString(++i, warehouse.getName());
        statement.setString(++i, warehouse.getInfo());
        statement.setInt(++i, warehouse.getCapacity());
        statement.setBoolean(++i, warehouse.isBottom());
        statement.setLong(++i, warehouse.getParentID());
        statement.setLong(++i, warehouse.getAccountID());
        statement.setLong(++i, warehouse.getTopWarehouseID());
        statement.setBoolean(++i, warehouse.isActive());

        return statement;
    }

    @Override
    public List<Warehouse> findAll() {
        try {
            return jdbcTemplate.query(Queries.SQL_SELECT_ALL_WAREHOUSES, warehouseRowMapper);

        } catch (DataAccessException e) {
            throw new WarehouseNotFoundException("Error during finding all warehouses", e);
        }
    }

    @Override
    public Warehouse findById(Long id) {
        try {
            return jdbcTemplate.queryForObject(Queries.SQL_SELECT_WAREHOUSE_BY_ID, warehouseRowMapper, id);
        } catch (EmptyResultDataAccessException e) {
            throw new WarehouseNotFoundException(e.getMessage());

        } catch (DataAccessException e) {
            throw new CRUDException("find warehouse by id = " + id, e);
        }

    }

    @Override
    public Warehouse create(Warehouse warehouse) {
        try {
            GeneratedKeyHolder holder = new GeneratedKeyHolder();
            jdbcTemplate.update(connection -> createWarehouseStatement(warehouse, connection), holder);
            warehouse.setId(Optional.ofNullable(holder.getKey())
                .map(Number::longValue)
                .orElseThrow(() -> new CRUDException("Error during an warehouse creation: " +
                    "Autogenerated key is null")));

        } catch (DataAccessException e) {
            throw new CRUDException("create warehouse id = " + warehouse.getId(), e);
        }
        return warehouse;
    }


    @Override
    public Warehouse update(Warehouse warehouse) {
        int status;
        try {
            status = jdbcTemplate.update(Queries.SQL_UPDATE_WAREHOUSE,
                warehouse.getName(), warehouse.getInfo(), warehouse.getCapacity(),
                warehouse.isBottom(), warehouse.getParentID(), warehouse.getAccountID(),
                warehouse.isActive(), warehouse.getChildren());

        } catch (DataAccessException e) {
            throw new CRUDException("update warehouse id = " + warehouse.getId(), e);
        }
        if (status == 0)
            throw new WarehouseNotFoundException("Update warehouse exception id = " + warehouse.getId());

        return warehouse;
    }

    @Override
    public boolean softDelete(Long id) {
        int status;
        try {
            status = jdbcTemplate.update(Queries.SQL_SET_ACTIVE_STATUS_WAREHOUSE, false, id);
        } catch (DataAccessException e) {
            throw new CRUDException("Error during soft `delete` warehouse {id = " + id + "}", e);
        }
        if (status == 0) {
            throw new WarehouseNotFoundException("Failed to obtain warehouse during soft `delete` {id = " + id + "}");
        }

        return true;
    }


    @Override
    public List<Warehouse> findChildrenByID(Long id) {
        try {
            return jdbcTemplate.query(Queries.SQL_SELECT_CHILDREN_BY_TOP_WAREHOUSE_ID, warehouseRowMapper);

        } catch (DataAccessException e) {
            throw new WarehouseNotFoundException("Error during finding all children of top-level-warehouse", e);
        }
    }

    class Queries {

        static final String SQL_CREATE_WAREHOUSE = "INSERT INTO warehouses(name, info, capacity, is_bottom, parent_id," +
            " account_id, top_warehouse_id, active) VALUES(?,?,?,?,?,?,?,?)";

        static final String SQL_SELECT_WAREHOUSE_BY_ID = "SELECT * FROM warehouses WHERE id = ?";

        static final String SQL_SELECT_ALL_WAREHOUSES = "SELECT * FROM warehouses";

        static final String SQL_UPDATE_WAREHOUSE = "UPDATE warehouses SET name= ?, info = ?," +
            "capacity = ?, is_bottom = ?, top_warehouse_id = ?, active = ? WHERE id = ?";

        static final String SQL_SELECT_CHILDREN_BY_TOP_WAREHOUSE_ID = "SELECT * FROM warehouses WHERE top_warehouse_id = ?";

        static final String SQL_SET_ACTIVE_STATUS_WAREHOUSE = "UPDATE warehouse SET active = ? WHERE id = ?";
    }
}
