package com.ita.if103java.ims.dao.impl;

import com.ita.if103java.ims.dao.EventDao;
import com.ita.if103java.ims.entity.Event;
import com.ita.if103java.ims.entity.EventName;
import com.ita.if103java.ims.entity.EventType;
import com.ita.if103java.ims.entity.Role;
import com.ita.if103java.ims.entity.User;
import com.ita.if103java.ims.exception.CRUDException;
import com.ita.if103java.ims.exception.EventNotFoundException;
import com.ita.if103java.ims.mapper.jdbc.EventRowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.data.domain.Pageable;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringJoiner;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.ita.if103java.ims.util.JDBCUtils.createWithAutogeneratedId;

@Repository
public class EventDaoImpl implements EventDao {

    private JdbcTemplate jdbcTemplate;
    private EventRowMapper eventRowMapper;

    @Autowired
    public EventDaoImpl(JdbcTemplate jdbcTemplate, EventRowMapper eventRowMapper) {
        this.jdbcTemplate = jdbcTemplate;
        this.eventRowMapper = eventRowMapper;
    }

    @Override
    public Event create(Event event) {
        try {
            event.setId(
                createWithAutogeneratedId(Long.class, (keyHolder) ->
                    jdbcTemplate.update(connection -> getPreparedStatement(connection, event), keyHolder))
            );
            return event;
        } catch (DataAccessException e) {
            throw new CRUDException("Error during `create` {id = " + event.getId() + "}EventDao.create", e);
        }
    }

    @Override
    public Event findById(Long id) {
        try {
            return jdbcTemplate.queryForObject(Queries.SQL_SELECT_EVENT_BY_ID, eventRowMapper, id);
        } catch (EmptyResultDataAccessException e) {
            throw new EventNotFoundException("Failed to obtain event during `select` {id = " + id + "}, EventDao.findById", e);
        } catch (DataAccessException e) {
            throw new CRUDException("Error during `select` {id = " + id + "}, EventDao.findById", e);
        }
    }

    @Override
    public List<Event> findAll(Pageable pageable, Map<String, ?> params, User user) {
        String account_condition = buildSqlFilterCondition("account_id", user.getAccountId());
        String privatCondition = null;
        if (user.getRole().equals(Role.WORKER)) {
            if (params.containsKey("name")) {
                params.remove("type");
                privatCondition = buildSqlFilterConditionForWorkerByName(params, user.getId());
            } else if (params.containsKey("type")) {
                privatCondition = buildSqlFilterForWorkerByType(params, user.getId());
            } else {
                privatCondition = "("
                    .concat(buildSqlFilterConditionHidePersonal())
                    .concat(" or ")
                    .concat(buildSqlFilterConditionShowPersonalForUser(user.getId()))
                    .concat(")");
            }
        }
        String typeAndNameConditions = Stream
            .of("type", "name")
            .filter(params::containsKey)
            .map(x -> buildSqlFilterCondition(x, params.get(x)))
            .collect(Collectors.joining("\n and "));

        String conditions = Stream
            .of("warehouse_id", "author_id", "date", "after", "before")
            .filter(params::containsKey)
            .map(x -> buildSqlFilterCondition(x, params.get(x)))
            .collect(Collectors.joining("\n and "));
        String where;

        if (typeAndNameConditions.isBlank()) {
            where = privatCondition;
        } else {
            if (privatCondition != null) {
                where = "(" + typeAndNameConditions + " or " + privatCondition + ")";
            } else {
                where = typeAndNameConditions;
            }
            ;
        }
        if (!conditions.isBlank()) {
            where = conditions + " and " + where;
        }
        System.out.println(conditions);
        System.out.println(typeAndNameConditions);
        System.out.println(privatCondition);
        System.out.println(where);
        String sort = pageable.getSort().toString().replaceAll(": ", " ");
        final String query = String.format("""
                select * from events where %s ORDER BY %s Limit %s OFFSET %s
                """,
            conditions.isBlank() ? account_condition : account_condition + " and " + conditions,
            sort, pageable.getPageSize(), pageable.getOffset());
        try {
            return jdbcTemplate.query(query, eventRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new EventNotFoundException("Failed to obtain event during " + query + ", EventDao.findAll", e);
        } catch (DataAccessException e) {
            throw new CRUDException("Error during  " + query + ", EventDao.findAll", e);
        }
    }

    private String buildSqlFilterConditionForWorkerByName(Map<String, ?> params, Long userId) {
        String condition = null;
        if (params.get("name") instanceof Collection) {
            List<String> names = new ArrayList<>();
            for (String name : (Collection<String>) params.get("name")) {
                if (EventName.valueOf(name).getType().equals(EventType.USER)) {
                    names.add(name);
                }
            }
            for (String name : names) {
                ((Collection<String>) params.get("name")).remove(name);
            }
            if (((Collection<String>) params.get("name")).isEmpty()) {
                params.remove("name");
            }
            if (!names.isEmpty()) {
                condition = "("
                    .concat(buildSqlFilterCondition("name", names))
                    .concat(" and ")
                    .concat(buildSqlFilterCondition("author_id", userId))
                    .concat(")");
            }
        } else if (EventName.valueOf((String) params.get("name")).getType().equals(EventType.USER)) {
            condition = "("
                .concat(buildSqlFilterCondition("name", params.get("name")))
                .concat(" and ")
                .concat(buildSqlFilterCondition("author_id", userId))
                .concat(")");
            params.remove("name");
        }
        return condition;
    }

    private String buildSqlFilterForWorkerByType(Map<String, ?> params, Long userId) {
        String condition = null;
        if (params.get("type") instanceof Collection && ((Collection) params.get("type")).contains("USER")) {
            ((Collection) params.get("type")).remove("USER");
            if (((Collection) params.get("type")).size() > 0) {
                condition = buildSqlFilterConditionShowPersonalForUser(userId);
            } else {
                params.remove("type");
                condition = buildSqlFilterConditionShowPersonalForUser(userId);
            }
        } else if (params.get("type").equals("USER")) {
            params.remove("type");
            condition = buildSqlFilterConditionShowPersonalForUser(userId);
        }
        return condition;
    }

    private String buildSqlFilterConditionHidePersonal() {
        String typeCondition = "("
            .concat(buildSqlFilterCondition("type", EventType.USER))
            .concat(")");
        return typeCondition.replace("in", "not in");
    }

    private String buildSqlFilterConditionShowPersonalForUser(Long userId) {
        String typeCondition = buildSqlFilterCondition("type", EventType.USER);
        return "("
            .concat(typeCondition)
            .concat(" and ")
            .concat(buildSqlFilterCondition("author_id", userId))
            .concat(")");
    }

    private String buildSqlFilterCondition(String columnName, Object columnValue) {
        if (columnValue instanceof Collection && !columnName.equals("type")) {
            StringJoiner values = new StringJoiner("', '", "'", "'");
            for (Object value : (Collection<Object>) columnValue) {
                values.add(value.toString());
            }
            return String.format("%s in (%s)", columnName, values);
        }
        if (columnName.equals("type")) {
            Set<EventName> names = new HashSet<>();
            if (columnValue instanceof Collection) {
                for (Object type : (Collection) columnValue) {
                    names.addAll(EventName.getValuesByType(EventType.valueOf(type.toString())));
                }
            } else {
                names = EventName.getValuesByType(EventType.valueOf(columnValue.toString()));
            }
            return buildSqlFilterCondition("name", names);
        }
        if (columnName.equals("date")) {
            return String.format("DATE(date) = '%s'", columnValue);
        }
        if (columnName.equals("after")) {
            return String.format("DATE(date) >= '%s'", columnValue);
        }
        if (columnName.equals("before")) {
            return String.format("DATE(date) <= '%s'", columnValue);
        }
        return String.format("%s %s '%s'", columnName, "=", columnValue);
    }

    private PreparedStatement getPreparedStatement(Connection connection, Event event) throws SQLException {
        PreparedStatement preparedStatement = connection.prepareStatement(Queries.SQL_CREATE_EVENT, Statement.RETURN_GENERATED_KEYS);
        int i = 0;
        preparedStatement.setString(++i, event.getMessage());
        preparedStatement.setObject(++i, event.getDate().toLocalDateTime());
        preparedStatement.setLong(++i, event.getAccountId());
        preparedStatement.setLong(++i, event.getAuthorId());
        preparedStatement.setObject(++i, event.getWarehouseId() != null ? event.getWarehouseId() : null);
        preparedStatement.setString(++i, event.getName().toString());
        preparedStatement.setObject(++i, event.getTransactionId() != null ? event.getTransactionId() : null);
        return preparedStatement;
    }

    class Queries {

        static final String SQL_CREATE_EVENT = """
                INSERT INTO events
                (message, date, account_id, author_id, warehouse_id, name, transaction_id)
                VALUES(?,?,?,?,?,?,?)
            """;

        static final String SQL_SELECT_EVENT_BY_ID = """
                SELECT *
                FROM events
                WHERE id = ?
            """;
    }
}
