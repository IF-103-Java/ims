package com.ita.if103java.ims.dao.impl;

import com.ita.if103java.ims.config.GeneratedKeyHolderFactory;
import com.ita.if103java.ims.dao.EventDao;
import com.ita.if103java.ims.entity.Event;
import com.ita.if103java.ims.entity.EventName;
import com.ita.if103java.ims.entity.EventType;
import com.ita.if103java.ims.entity.Role;
import com.ita.if103java.ims.entity.User;
import com.ita.if103java.ims.exception.dao.CRUDException;
import com.ita.if103java.ims.exception.dao.EventNotFoundException;
import com.ita.if103java.ims.mapper.jdbc.EventRowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringJoiner;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.ita.if103java.ims.util.JDBCUtils.createWithAutogeneratedId;

@Repository
public class EventDaoImpl implements EventDao {

    private JdbcTemplate jdbcTemplate;
    private EventRowMapper eventRowMapper;
    private GeneratedKeyHolderFactory generatedKeyHolderFactory;

    @Autowired
    public EventDaoImpl(JdbcTemplate jdbcTemplate,
                        EventRowMapper eventRowMapper,
                        GeneratedKeyHolderFactory generatedKeyHolderFactory) {
        this.jdbcTemplate = jdbcTemplate;
        this.eventRowMapper = eventRowMapper;
        this.generatedKeyHolderFactory = generatedKeyHolderFactory;
    }

    @Override
    public Event create(Event event) {
        try {
            event.setId(
                createWithAutogeneratedId(Long.class, (keyHolder) ->
                        jdbcTemplate.update(connection -> getPreparedStatement(connection, event), keyHolder),
                    generatedKeyHolderFactory.newKeyHolder())
            );
            return event;
        } catch (DataAccessException e) {
            throw new CRUDException("Error during `create` {id = " + event.getId() + "}EventDao.create", e);
        }
    }

    @Override
    public Page<Event> findAll(Pageable pageable, Map<String, ?> params, User user) {
        Map<String, Set> paramsNameAndType = new HashMap<>();
        if (params.containsKey("name")) {
            if (params.get("name") instanceof Collection) {
                paramsNameAndType.put("name", new HashSet((Collection<String>) params.get("name")));
            } else {
                paramsNameAndType.put("name", new HashSet(Arrays.asList(params.get("name"))));
            }
            params.remove("type");
        } else {
            if (params.containsKey("type")) {
                if (params.get("type") instanceof Collection) {
                    paramsNameAndType.put("type", new HashSet<>((Collection<String>) params.get("type")));
                } else {
                    paramsNameAndType.put("type", new HashSet(Arrays.asList(params.get("type"))));
                }
                params.remove("type");
            }
        }
        String accountCondition = buildSqlCondition("account_id", user.getAccountId());
        String personalConditions = "";
        if (user.getRole().equals(Role.ROLE_WORKER)) {
            if (paramsNameAndType.containsKey("name")) {
                personalConditions = buildSqlNameCondition(paramsNameAndType.get("name"), user.getId());
                if (paramsNameAndType.get("name").isEmpty()) {
                    paramsNameAndType.remove("name");
                }
            } else if (paramsNameAndType.containsKey("type")) {
                personalConditions = buildSqlTypeCondition(paramsNameAndType.get("type"), user.getId());
                if (paramsNameAndType.get("type").isEmpty()) {
                    paramsNameAndType.remove("type");
                }
            } else {
                personalConditions = "("
                    .concat(buildSqlPrivacyCondition())
                    .concat(" or ")
                    .concat(buildSqlDefaultCondition(user.getId()))
                    .concat(")");
            }
        }

        String typeAndNameConditions = Stream
            .of("type", "name")
            .filter(paramsNameAndType::containsKey)
            .map(x -> buildSqlCondition(x, paramsNameAndType.get(x)))
            .collect(Collectors.joining("\n and "));

        String conditions = Stream
            .of("warehouse_id", "author_id", "date", "after", "before")
            .filter(params::containsKey)
            .map(x -> buildSqlCondition(x, params.get(x)))
            .collect(Collectors.joining("\n and "));

        String where;
        if (typeAndNameConditions.isBlank()) {
            where = personalConditions;
        } else {
            if (!personalConditions.isBlank()) {
                where = "(" + typeAndNameConditions + " or " + personalConditions + ")";
            } else {
                where = typeAndNameConditions;
            }
        }
        if (!conditions.isBlank()) {
            if (!where.isBlank()) {
                where = conditions + " and " + where;
            } else {
                where = conditions;
            }
        }
        where = where.isBlank() ? accountCondition : accountCondition.concat(" and " + where);
        String sort = pageable.getSort().toString().replaceAll(": ", " ");
        final String querySelectEvents = String.format("""
                select * from events where %s ORDER BY %s Limit %s OFFSET %s
                """,
            where, sort, pageable.getPageSize(), pageable.getOffset());
        final String rowCountSql = String.format("""
            select count(1) from events where %s
            """, where);
        try {
            List<Event> events = jdbcTemplate.query(querySelectEvents, eventRowMapper);
            Integer rowCount = jdbcTemplate.queryForObject(rowCountSql, Integer.class);
            return new PageImpl<>(events, pageable, rowCount);
        } catch (EmptyResultDataAccessException e) {
            throw new EventNotFoundException("Failed to obtain event during " + querySelectEvents + ", EventDao.findAll", e);
        } catch (DataAccessException e) {
            throw new CRUDException("Error during  " + querySelectEvents + ", EventDao.findAll", e);
        }
    }

    private String buildSqlNameCondition(Set<String> names, Long userId) {
        String condition = "";
        List<String> userEventNames = new ArrayList<>();
        for (String name : names) {
            if (EventName.valueOf(name).getType().equals(EventType.USER)) {
                userEventNames.add(name);
            }
        }
        for (String name : userEventNames) {
            names.remove(name);
        }
        Collections.sort(userEventNames);
        if (!userEventNames.isEmpty()) {
            condition = "("
                .concat(buildSqlCondition("name", userEventNames))
                .concat(" and ")
                .concat(buildSqlCondition("author_id", userId))
                .concat(")");
        }
        return condition;
    }

    private String buildSqlTypeCondition(Set<String> types, Long userId) {
        String condition = "";
        if (types.contains("USER")) {
            condition = buildSqlDefaultCondition(userId);
            types.remove("USER");
        }
        return condition;
    }

    private String buildSqlPrivacyCondition() {
        return "("
            .concat(buildSqlCondition("type", EventType.USER))
            .concat(")")
            .replace("in", "not in");
    }

    private String buildSqlDefaultCondition(Long userId) {
        return "("
            .concat(buildSqlCondition("type", EventType.USER))
            .concat(" and ")
            .concat(buildSqlCondition("author_id", userId))
            .concat(")");
    }

    private String buildSqlCondition(String columnName, Object columnValue) {
        if (columnValue instanceof Collection && !columnName.equals("type")) {
            StringJoiner values = new StringJoiner("', '", "'", "'");
            for (Object value : (Collection<Object>) columnValue) {
                values.add(value.toString());
            }
            return String.format("%s in (%s)", columnName, values);
        }

        if (columnName.equals("type")) {
            Set<EventName> names = new TreeSet<>(new Comparator<EventName>() {
                @Override
                public int compare(EventName o1, EventName o2) {
                    return o1.getLabel().compareTo(o2.getLabel());
                }
            });
            if (columnValue instanceof Collection) {
                for (Object type : (Collection) columnValue) {
                    names.addAll(EventName.getValuesByType(EventType.valueOf(type.toString())));
                }
            } else {
                names.addAll(EventName.getValuesByType(EventType.valueOf(columnValue.toString())));
            }

            return buildSqlCondition("name", names);
        }
        if (columnName.equals("date")) {
            return String.format("DATE(date) = '%s'", columnValue);
        }
        if (columnName.equals("after")) {
            return String.format("DATE(date) >= '%s'", columnValue);
        }
        if (columnName.equals("before")) {
            return String.format("DATE(date) <= '%s'", columnValue);
        }
        return String.format("%s %s '%s'", columnName, "=", columnValue);
    }

    @Override
    public void deleteByAccountId(Long accountId) {
        try {
            jdbcTemplate.update(Queries.SQL_DELETE_BY_ACCOUNT_ID, accountId);
        } catch (DataAccessException e) {
            throw new CRUDException("Error during  " + Queries.SQL_DELETE_BY_ACCOUNT_ID + accountId +
                ", EventDao.deleteByAccountId", e);
        }
    }

    private PreparedStatement getPreparedStatement(Connection connection, Event event) throws SQLException {
        PreparedStatement preparedStatement = connection.prepareStatement(Queries.SQL_CREATE_EVENT, Statement.RETURN_GENERATED_KEYS);
        int i = 0;
        preparedStatement.setString(++i, event.getMessage());
        preparedStatement.setObject(++i, event.getDate().toLocalDateTime());
        preparedStatement.setLong(++i, event.getAccountId());
        preparedStatement.setLong(++i, event.getAuthorId());
        preparedStatement.setObject(++i, event.getWarehouseId());
        preparedStatement.setString(++i, event.getName().toString());
        preparedStatement.setObject(++i, event.getTransactionId());
        return preparedStatement;
    }

    class Queries {

        static final String SQL_CREATE_EVENT = """
                INSERT INTO events
                (message, date, account_id, author_id, warehouse_id, name, transaction_id)
                VALUES(?,?,?,?,?,?,?)
            """;

        static final String SQL_DELETE_BY_ACCOUNT_ID = """
                DELETE
                FROM events
                WHERE account_id = ?
            """;
    }
}
