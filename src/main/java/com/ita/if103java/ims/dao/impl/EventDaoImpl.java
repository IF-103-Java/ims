package com.ita.if103java.ims.dao.impl;

import com.ita.if103java.ims.config.GeneratedKeyHolderFactory;
import com.ita.if103java.ims.dao.EventDao;
import com.ita.if103java.ims.entity.Event;
import com.ita.if103java.ims.entity.EventName;
import com.ita.if103java.ims.entity.EventType;
import com.ita.if103java.ims.entity.Role;
import com.ita.if103java.ims.entity.User;
import com.ita.if103java.ims.exception.dao.CRUDException;
import com.ita.if103java.ims.exception.dao.EventNotFoundException;
import com.ita.if103java.ims.mapper.jdbc.EventRowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringJoiner;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.ita.if103java.ims.util.JDBCUtils.createWithAutogeneratedId;

@Repository
public class EventDaoImpl implements EventDao {

    private JdbcTemplate jdbcTemplate;
    private EventRowMapper eventRowMapper;
    private GeneratedKeyHolderFactory generatedKeyHolderFactory;

    @Autowired
    public EventDaoImpl(JdbcTemplate jdbcTemplate,
                        EventRowMapper eventRowMapper,
                        GeneratedKeyHolderFactory generatedKeyHolderFactory) {
        this.jdbcTemplate = jdbcTemplate;
        this.eventRowMapper = eventRowMapper;
        this.generatedKeyHolderFactory = generatedKeyHolderFactory;
    }

    @Override
    public Event create(Event event) {
        try {
            event.setId(
                createWithAutogeneratedId(Long.class, (keyHolder) ->
                        jdbcTemplate.update(connection -> getPreparedStatement(connection, event), keyHolder),
                    generatedKeyHolderFactory.newKeyHolder())
            );
            return event;
        } catch (DataAccessException e) {
            throw new CRUDException("Error during `create` {id = " + event.getId() + "}EventDao.create", e);
        }
    }

    @Override
    public Page<Event> findAll(Pageable pageable, Map<String, ?> params, User user) {
        Set<EventName> eventNames = new TreeSet<>(Comparator.comparing(Enum::toString));
        if (params.containsKey("type")) {
            for (String eventType : (Collection<String>) params.get("type")) {
                eventNames.addAll(EventName.getValuesByType(EventType.valueOf(eventType)));
            }
        }
        if (params.containsKey("name")) {
            for (String eventName : (Collection<String>) params.get("name")) {
                eventNames.add(EventName.valueOf(eventName));
            }
        }

        String accountCondition = String.format("account_id = '%s'", user.getAccountId());

        String personalConditions = "";

        if (user.getRole().equals(Role.ROLE_WORKER)) {
            personalConditions = restrictPersonalEventsForWorker(params, user, eventNames);
        }

        String conditions = Stream
            .of("warehouse_id", "author_id", "date", "after", "before")
            .filter(params::containsKey)
            .map(x -> buildSqlCondition(x, params.get(x)))
            .collect(Collectors.joining("\n and "));

        String eventNameCondition;
        if (eventNames.isEmpty()) {
            eventNameCondition = personalConditions;
        } else {
            eventNameCondition = buildSqlCondition("name", eventNames);
            if (!personalConditions.isBlank()) {
                eventNameCondition = "(" + eventNameCondition + " or " + personalConditions + ")";
            }
        }
        String where = Stream.of(accountCondition, conditions, eventNameCondition)
            .filter(x -> !x.isBlank()).collect(Collectors.joining(" and "));

        String sort = pageable.getSort().toString().replaceAll(": ", " ");
        final String querySelectEvents = String.format("""
                SELECT * FROM events WHERE %s ORDER BY %s LIMIT %s OFFSET %s
                """,
            where, sort, pageable.getPageSize(), pageable.getOffset());
        final String rowCountSql = String.format("""
            SELECT COUNT(1) FROM events WHERE %s
            """, where);
        try {
            List<Event> events = jdbcTemplate.query(querySelectEvents, eventRowMapper);
            Integer rowCount = jdbcTemplate.queryForObject(rowCountSql, Integer.class);
            return new PageImpl<>(events, pageable, rowCount);
        } catch (
            EmptyResultDataAccessException e) {
            throw new EventNotFoundException("Failed to obtain event during " + querySelectEvents + ", EventDao.findAll", e);
        } catch (
            DataAccessException e) {
            throw new CRUDException("Error during  " + querySelectEvents + ", EventDao.findAll", e);
        }
    }

    private String restrictPersonalEventsForWorker(Map<String, ?> params, User user, Set<EventName> eventNames) {
        String personalConditions;
        boolean showPersonalEvents =
            !params.containsKey("author_id") ||
                collectionContainsElement((Collection) params.get("author_id"), user.getId());


        if (!eventNames.isEmpty()) {
            if (!showPersonalEvents) {
                eventNames.removeIf(o -> o.getType().equals(EventType.USER));
            }

            personalConditions = buildSqlNameCondition(eventNames, user.getId());

            if (eventNames.isEmpty() && !showPersonalEvents) {
                personalConditions = "name in ('')";
            }
        } else {
            personalConditions = showPersonalEvents ?
                "(".concat(buildSqlPrivacyCondition())
                    .concat(" or ")
                    .concat(buildSqlDefaultCondition(user.getId()))
                    .concat(")") :
                buildSqlPrivacyCondition();
        }
        return personalConditions;
    }

    private boolean collectionContainsElement(Collection collection, Object target) {
        for (Object elem : collection) {
            if (elem.toString().equals(target.toString())) {
                return true;
            }
        }
        return false;
    }

    private String buildSqlNameCondition(Set<EventName> eventNames, Long userId) {
        String condition = "";
        Set<EventName> personalEventNames = new TreeSet<>(Comparator.comparing(Enum::toString));

        eventNames.stream().filter(eventName -> eventName.getType().equals(EventType.USER)).
            forEach(personalEventNames::add);

        eventNames.removeIf(o -> o.getType().equals(EventType.USER));

        if (!personalEventNames.isEmpty()) {
            condition = "("
                .concat(buildSqlCondition("name", personalEventNames))
                .concat(" and ")
                .concat(buildSqlCondition("author_id", userId))
                .concat(")");
        }
        return condition;
    }

    private String buildSqlPrivacyCondition() {
        return "("
            .concat(buildSqlCondition("name", EventName.getValuesByType(EventType.USER)))
            .concat(")")
            .replace("in", "not in");
    }

    private String buildSqlDefaultCondition(Long userId) {
        return "("
            .concat(buildSqlCondition("name", EventName.getValuesByType(EventType.USER)))
            .concat(" and ")
            .concat(buildSqlCondition("author_id", userId))
            .concat(")");
    }

    private String buildSqlCondition(String columnName, Object columnValue) {
        if (columnName.equals("date")) {
            return String.format("DATE(date) = '%s'", columnValue);
        }
        if (columnName.equals("after")) {
            return String.format("DATE(date) >= '%s'", columnValue);
        }
        if (columnName.equals("before")) {
            return String.format("DATE(date) <= '%s'", columnValue);
        }

        if (columnValue instanceof Collection) {
            StringJoiner values = new StringJoiner("', '", "'", "'");
            for (Object value : (Collection<Object>) columnValue) {
                values.add(value.toString());
            }
            return String.format("%s in (%s)", columnName, values);
        }


        return String.format("%s %s '%s'", columnName, "=", columnValue);
    }

    @Override
    public void deleteByAccountId(Long accountId) {
        try {
            jdbcTemplate.update(Queries.SQL_DELETE_BY_ACCOUNT_ID, accountId);
        } catch (DataAccessException e) {
            throw new CRUDException("Error during  " + Queries.SQL_DELETE_BY_ACCOUNT_ID + accountId +
                ", EventDao.deleteByAccountId", e);
        }
    }

    private PreparedStatement getPreparedStatement(Connection connection, Event event) throws SQLException {
        PreparedStatement preparedStatement = connection.prepareStatement(Queries.SQL_CREATE_EVENT, Statement.RETURN_GENERATED_KEYS);
        int i = 0;
        preparedStatement.setString(++i, event.getMessage());
        preparedStatement.setObject(++i, event.getDate().toLocalDateTime());
        preparedStatement.setLong(++i, event.getAccountId());
        preparedStatement.setLong(++i, event.getAuthorId());
        preparedStatement.setObject(++i, event.getWarehouseId());
        preparedStatement.setString(++i, event.getName().toString());
        preparedStatement.setObject(++i, event.getTransactionId());
        return preparedStatement;
    }

    class Queries {

        static final String SQL_CREATE_EVENT = """
                INSERT INTO events
                (message, date, account_id, author_id, warehouse_id, name, transaction_id)
                VALUES(?,?,?,?,?,?,?)
            """;

        static final String SQL_DELETE_BY_ACCOUNT_ID = """
                DELETE
                FROM events
                WHERE account_id = ?
            """;
    }
}
